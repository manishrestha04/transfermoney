@app.get("/", response_class=HTMLResponse)
async def get(authenticated: bool = Depends(authenticate_user)):
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Interview Assistant</title>
    </head>
    <body>
        <h1>Interview Assistant</h1>
        <form id="cvForm" method="post" action="/set_cv_jd/">
        <label for="cvText">Enter CV:</label><br>
        <textarea id="cvText" name="cv" rows="2" cols="50" required></textarea><br><br>

        <label for="jdText">Enter Job Description (JD):</label><br>
        <textarea id="jdText" name="jd" rows="2" cols="50" required></textarea><br><br>

        <button type="submit">Submit CV and JD</button>
        </form>

        <button id="recordButton">Start Recording</button>
        <button id="stopButton" disabled>Stop Recording</button>
        <audio id="audioPlayback" controls></audio>
        <h2>Question:</h2>
        <p id="transcriptionText"></p>
        <h2>Answer:</h2>
        <p id="chunkText"></p>

        <script>
            let mediaRecorder;
            let audioChunks = [];
            const recordButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton');
            const audioPlayback = document.getElementById('audioPlayback');
            const transcriptionText = document.getElementById('transcriptionText');
            const chunkText = document.getElementById('chunkText');

            recordButton.addEventListener('click', async () => {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.start();

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayback.src = audioUrl;

                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.wav');

                    // Fetch the streamed response
                    const response = await fetch('/upload/', {
                        method: 'POST',
                        body: formData
                    });

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    chunkText.innerHTML = ''; // Clear previous content

                    let firstChunk = true;
// Stream the response
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value, { stream: true });

                        if (firstChunk) {
                            transcriptionText.innerText = chunk; // Display transcription as the question
                            firstChunk = false;
                        } else {
                            // Replace newline characters with <br> for HTML rendering
                            chunkText.innerHTML += chunk.replace(/\\n/g, '<br>');
                        }
                    }

                    audioChunks = []; // Reset audioChunks for the next recording
                };

                recordButton.disabled = true;
                stopButton.disabled = false;
            });

            stopButton.addEventListener('click', () => {
                mediaRecorder.stop();
                recordButton.disabled = false;
                stopButton.disabled = true;
            });
        </script>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)